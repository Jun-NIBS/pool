maxP_search <- function(X, Y, classlist, Nrec, itr=400, Nlib = 1e5, minLen, maxLen, Gamma_1, Gamma_0, add_ins = 1) 
{
#================================================================================
#Function: maxP_search
#
#--------------------------------------------------------------------------------
#Description:
#    give a set of recommendations S that maximize P(at least one peptide in S is hit)
#
#--------------------------------------------------------------------------------
#Input arguments:
#	 classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    Nrec
# 			 No. of recommendations to be generated
# 	 itr
#			 Iteration needed for calculation prob being hit
#	 Nlib
# 			 No. of peptides considered for searching optimal
#	 maxL
#	 		 max no. of AAs to the left of Serine
#	 maxR
#	 		 max no. of AAs to the right of Serine
#	 rootpath
#	 		 path of src folder
#
#--------------------------------------------------------------------------------
#Return objects:
#    a list
#            result$rec:	matrix with each row representing a recommended peptide  
#--------------------------------------------------------------------------------
	nF <- dim(X)[2]
	nAA <- length(unique(as.numeric(classlist)))
	rec <- c()
	trainX <- X
	trainY <- Y	
	nPep <- 0
	maxL <- ceiling(maxLen*0.6)
	maxR <- ceiling(maxLen*0.8)
	while(nPep < Nrec) {	
		tL <- ceiling(runif(1)*(maxLen - minLen)) + minLen
        ratioL <- runif(1)*0.4 + 0.2
		L <- floor(tL * ratioL)
		R <- tL - L
		# sample random peptides	
		peptides.library <- matrix(-1, nrow=Nlib, ncol=nF)
		rdn.peptides <- ceiling(replicate(L+R, runif(Nlib)*nAA))
		peptides.library[, (nF/2-L+1):(nF/2+R)] <- rdn.peptides
		colnames(peptides.library) <- colnames(trainX)
		# train & predict
		prob <- 0
		alpha <- Dirichlet_Parameter(trainX, trainY, classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1)
		for (i in 1:itr) {
			theta <- getTheta_MC(alpha = alpha, classlist = classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1)
			prob <- NB_predict(peptides.library, theta, maxL = maxL, maxR = maxR) + prob
		}
		prob <- prob/ itr
		# find one peptide with highest prob being hit, is recommendation
		is_added <- FALSE
		while(!is_added) {
			best_index <- which(prob==max(prob))
			add_pep <- peptides.library[best_index,]
			if(dim(unique(rbind(rec,add_pep)))[1] > nPep){
				rec <- rbind(rec, add_pep)
				nPep <- nPep + 1
				is_added <- TRUE
				for(i in 1:add_ins){
					trainX <- rbind(trainX, rec[nPep,])
				}
				trainY <- c(trainY, rep(0,add_ins))	
			}
			else {
				peptides.library <- peptides.library[-best_index,]
				prob <- prob[-best_index]
			}
		}		
	}
	colnames(rec) <- colnames(X)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}





######################################################################################
maxP_search_2 <- function(X, Y, classlist, Nrec, maxLen, minLen, Gamma_0, Gamma_1, add_ins = 1) 
{
#=====================================================================================
#	 An alternative version of maxP_search, major differences:
#		  1. theta parameter is obtained by point estimation
#		  2. Recommendation list of peptides, therefore, is generated by picking the
#            class with highest theta at each position
#
#=====================================================================================
	nF <- dim(X)[2]
	nAA <- length(unique(as.numeric(classlist)))
	rec <- c()	
	trainX <- X
	trainY <- Y
	nPep <- 0
	while (nPep < Nrec) {		
		alpha <- Dirichlet_Parameter(trainX, trainY, classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1) 
		theta <- getTheta(alpha = alpha, classlist = classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1)
		ratio <- as.matrix(theta$theta_1) / as.matrix(theta$theta_0)
		best.class <- rep(0, nF)
		for (i in 1:nF) {
			best.class[i] <- which.max(ratio[,i])
		}
		# randomly choose length of peptide
		tL <- ceiling(runif(1)*(maxLen - minLen)) + minLen
        ratioL <- runif(1)*0.4 + 0.2
		L <- floor(tL * ratioL)
		R <- tL - L
		best.peptide <- rep(-1, nF)
		best.peptide[(nF/2-L+1):(nF/2+R)] <- best.class[(nF/2-L+1):(nF/2+R)]
		# if(dim(unique(rbind(rec,best.peptide)))[1] > nPep){
			rec <- rbind(rec, best.peptide)
			nPep = nPep + 1
			for(i in 1:add_ins){
				trainX <- rbind(trainX, rec[nPep,])
			}
		# }
	}
	colnames(rec) <- colnames(X)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}
		



maxP_search3 <- function(X, Y, classlist, Nrec, itr=400, peptides.library, maxL, maxR, Gamma_1, Gamma_0, add_ins = 1) 
{
#================================================================================
#Function: maxP_search3
#
#--------------------------------------------------------------------------------
#Description:
#    give a set of recommendations S that maximize P(at least one peptide in S is hit)
#
#--------------------------------------------------------------------------------
#Input arguments:
#	 classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    Nrec
# 			 No. of recommendations to be generated
# 	 itr
#			 Iteration needed for calculation prob being hit
#	 peptides.library
# 			 peptide library for search optimal
#
#--------------------------------------------------------------------------------
#Return objects:
#    a list
#            result$rec:	matrix with each row representing a recommended peptide  
#--------------------------------------------------------------------------------
	nF <- dim(X)[2]
	nAA <- length(unique(as.numeric(classlist)))
	rec <- c()
	trainX <- X
	trainY <- Y	
	colnames(peptides.library) <- colnames(trainX)
	nPep <- 0
	recIdx <- c()
	while(nPep < Nrec) {	
		# tL <- ceiling(runif(1)*(maxLen - minLen)) + minLen
  #       ratioL <- runif(1)*0.4 + 0.2
		# L <- floor(tL * ratioL)
		# R <- tL - L
		# sample random peptides	
		# peptides.library <- matrix(-1, nrow=Nlib, ncol=nF)
		# rdn.peptides <- ceiling(replicate(L+R, runif(Nlib)*nAA))
		# peptides.library[, (nF/2-L+1):(nF/2+R)] <- rdn.peptides
		
		# train & predict
		prob <- 0
		alpha <- Dirichlet_Parameter(trainX, trainY, classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1)
		for (i in 1:itr) {
			theta <- getTheta_MC(alpha = alpha, classlist = classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1)
			prob <- NB_predict(peptides.library, theta, maxL = maxL, maxR = maxR) + prob
		}
		prob <- prob/ itr
		# # find one peptide with highest prob being hit, is recommendation, delete repeated recommendation
		# is_added <- FALSE
		# while(!is_added) {
		# 	best_index <- which(prob==max(prob))
		# 	add_pep <- peptides.library[best_index,]
		# 	if(dim(unique(rbind(rec,add_pep)))[1] > nPep){
		# 		rec <- rbind(rec, add_pep)
		# 		nPep <- nPep + 1
		# 		is_added <- TRUE
		# 		for(i in 1:add_ins){
		# 			trainX <- rbind(trainX, rec[nPep,])
		# 		}
		# 		trainY <- c(trainY, rep(0,add_ins))	
		# 		# recIdx <- c(recIdx, best_index)
		# 	}
		# 	else {
		# 		peptides.library <- peptides.library[-best_index,]
		# 		prob <- prob[-best_index]
		# 	}
		# }	
		# find open peptide with highest prob being hit, without delete repeated recommendation
		best_index <- which(prob==max(prob))
		rec <- rbind(rec, peptides.library[best_index,])
		nPep <- nPep + 1
		for (i in 1:add_ins){
			trainX <- rbind(trainX, rec[nPep,])
		}
		trainY <- c(trainY, rep(0, add_ins))	
		recIdx <- c(recIdx, best_index)
	}
	colnames(rec) <- colnames(X)
	rownames(rec) <- c(1:dim(rec)[1])
	result <- list("rec"=rec, "idx"=recIdx)
	return (result)
}
#######################################################################################
ExpImprovement_par <- function(X, Y, newdata, classlist, nRep = 400, best.length = 20,
 prior.positive = 10**-4)
{
#================================================================================
#Function: ExpImprovement_par
#
#--------------------------------------------------------------------------------
#Description:
#    The parallel version of ExpImprovement. 
#        Given a set of peptides(newdata), computes the expected reduction in length 
#    of the shortest peptide known compared with current shortest length
#    (best.length).
#
#--------------------------------------------------------------------------------
#Input arguments:
#    train
#            A data matrix. Each row corresponds to a peptide and each column 
#            corresponds to a feature with the last column being the outcome
#            value.
#    newdata:
#            A data matrix whose rows correspond to peptides and columns to 
#            features. There shall be no outcome values.
#    classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    nRep:
#            Number of simulation replications.
#    best.length
#            Current shortest length of peptides working with both enzymes.
#    prior.positive
#            Prior distribution Pr(Y=1) where Y is the outcome value. The default 
#            10^-4. 
#
#--------------------------------------------------------------------------------
#Return objects:
#	 exp_reduc:
#        A list which contains:
#    improve
#            The desired expectation of reduction in length.
#    CI                 
#            The 95% percent confidence interval of exp.improve
#
#--------------------------------------------------------------------------------
    require(Rlab)
	nData <- dim(newdata)[1]
    #prob.hit: A binary vector. prob.hit[i] is the probability the ith peptide in 
	#          newdata is a hit(according to simulated posterior theta).
    prob.hit <- rep(0, nData)
	#is.hit: A binary vector. is.hit[i] = 1 if the ith peptide in newdata is a 
	#        hit. This vector is simulated according to  prob.hit.
	is.hit <- rep(0, nData)
	#reduction: A vector. reduction[i] is the reduction in the length compared
    #        	with best.length of the ith peptide in newdata if that peptide 
	#           is a hit
    #                     reduction[i] = 0 if is.hit[i] = 0
	#           reduction[i] = max(0,best.length-length(newdata[i])) 
	#           if is.hit[i] = 1
	
	#Calculate the length of all peptides in newdata
	peptide.length <- rowSums((newdata!=-1))
	#Initialize reduction
	reduction <- pmax(0,best.length - peptide.length)
	alpha <- Dirichlet_Parameter(X, Y, classlist, Gamma_0 = 1.5, Gamma_1 = 0.05)
	#max_reduction: A vector. max.reduction[i] = is the maximum reduction in the 
	#               length among all peptides in newdata in the ith simulation.
    max_reduction <- foreach(icount(nRep), .init = c(), .combine = append, 
			.packages = c('Rlab'), .export = c('getTheta_MC', 'NB_predict')) %dopar% {        
        theta <- getTheta_MC(alpha = alpha, classlist = classlist, Gamma_0 = 1.5, Gamma_1 = 0.05)
		data_for_cal <- newdata
		data_for_cal[newdata == -1] <- 9
		prob.hit <- NB_predict(data_for_cal, theta, maxL = 9, maxR = 10, prior.positive = prior.positive)
        #Simulate is.hit according to prob.hit
		is.hit <- rbern(nData, prob.hit)
		max(reduction*is.hit)
    }
    improve <- mean(max_reduction)
	CI <- c(improve-sd(max_reduction)*qnorm(0.975)/sqrt(nRep), improve+sd(max_reduction)*qnorm(0.975)/sqrt(nRep))
	exp_reduc <- list("improve" = improve, "CI" = CI) 
    return(exp_reduc)   
}





########################################################################################
ProbImprovement_par <- function(train, newdata, classlist, nRep, best.length = 11,
 prior.positive = 10**-4)
{
#================================================================================
#Function: ProbImprovement_par
#
#--------------------------------------------------------------------------------
#Description:
#    The parallel version of ProbImprovement. 
#        Computes the probability that at least one peptide with length shorter 
#    than previous best in newdata is a hit.
#
#--------------------------------------------------------------------------------
#Input arguments:
#    train
#            A data matrix. Each row corresponds to a peptide and each column 
#            corresponds to a feature with the last column being the outcome
#            value.
#    newdata:
#            A data matrix whose rows correspond to peptides and columns to 
#            features. There shall be no outcome values.
#    classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    nRep:
#            Number of simulation replications.
#    best.length
#            Current shortest length of peptides working with both enzymes.
#    prior.positive
#            Prior distribution Pr(Y=1) where Y is the outcome value. The default 
#            10^-4. 
#
#--------------------------------------------------------------------------------
#Return objects:
#    prob
#        A list which contains:
#    improve
#            The desired expected reduction. 
#    CI                
#            The 95% confidence interval of the desired probability.
#--------------------------------------------------------------------------------
	require(Rlab)
	nData <- dim(newdata)[1]
    #prob.hit: A binary vector. prob.hit[i] is the probability the ith peptide in 
	#          newdata is a hit(according to simulated posterior theta).
    prob.hit <- rep(0, nData)
	#is.hit: A binary vector. is.hit[i] = 1 if the ith peptide in newdata is a 
	#        hit, this vector is simulated according to  prob.hit
	is.hit <- rep(0, nData)
	#isShorter: A vector. isShorter[i] is the indicator of the ith peptide in 
	#           newdata being shorter than the best previous peptide.
	#Calculate the length of all peptides in newdata
	peptide.length <- rowSums(!is.na(newdata))
	is.shorter <- as.numeric(peptide.length < best.length)
    #is.found: A binary vector. In the ith simulation, if at least one of the 
	#          peptides in newdata is a hit and is shorter than best.length, 
	#      	   is.found[i] = 1, otherwise 0.
    is.found <- rep(0, nRep)
	alpha <- Dirichlet_Parameter(train, classlist)
    is.found <- foreach(icount(nRep), .combine = append, .init = c(), .packages = c('Rlab'),
	    .export = c('NB_predict','getTheta_MC')) %dopar% {        
        theta <- getTheta_MC(alpha = alpha, classlist = classlist)
		prob.hit <- NB_predict(newdata, theta, prior.positive = prior.positive)
        #Simulate is.hit according to prob.hit
		is.hit <- rbern(nData, prob.hit)
		as.numeric(any(is.hit*is.shorter > 0))
    }
    improve <- mean(is.found)
	CI <- c(improve-sd(is.found)*qnorm(0.975)/sqrt(nRep), improve+sd(is.found)*qnorm(0.975)/sqrt(nRep))
	prob <- list("improve" = improve, "CI" = CI)
    return(prob)   
}
