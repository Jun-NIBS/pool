maxP_search <- function(X, Y, classlist, S.Pos, Nrec, itr, Nlib, maxL, maxR, minL, minR, Gamma_0, Gamma_1, add_ins) 
{
#================================================================================================================================================================================
#Function: maxP_search
#
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Description:
#    	Generate a set of recommendations. To add a new recommendation to the set, Use the greedy heuristic, pick a peptide to maximize probability of improvement among a
#       randomly generated library of peptides. 
#
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Input arguments:
#	X
#		The matrix of training samples. Each row is a feature vector of a peptide.
#	Y
#		The vector of training labels.
#	classlist
#             	The vector specifying the class each amino-acid belongs to.  	
#	S.Pos
#		position of serene of a peptide IN THE MODEL, this parameter is determined by the model instead of training data or recommendations to be generated.
#	Nrec
# 		Size of the set of recommendations.
# 	itr
#		Iterations needed for calculation the probability of being hit using Monte Carlo simulation.
#	Nlib
# 		Size of the randomly generated library of peptides in each step of the greedy heuristic.
#	maxL, maxR, minL, minR
#	 	Maximum/minimum number of peptides to the left/right of serene for all the recommendations to be generated.
#	Gamma_0/Gamma_1:
#		The gamma parameters for computing posterior alpha parameters.
#	add_ins
#		The number of replications of a recommendation to be added into training set as non-hits after it is generated by the greedy heuristic.
#	
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Return objects:
#    	rec
#		a matrix with each row being the feature vector of a recommended peptide.  
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	nF <- dim(X)[2]
	nAA <- length(unique(as.numeric(classlist)))
	rec <- c()
	trainX <- X
	trainY <- Y	
	nPep <- 0

	#LD, RD are used for generating random peptide library
	LD <- rbind(upper.tri(matrix(1, maxL - minL, maxL - minL), diag = TRUE), rep(0, maxL - minL))
	RD <- rbind(upper.tri(matrix(1, maxR - minR, maxR - minR), diag = TRUE), rep(0, maxR - minR))
	while(nPep < Nrec) {	
		L <- ceiling(runif(1, min = minL-1, max = maxL))
		R <- ceiling(runif(1, min = minR-1, max = maxR))
		# sample random peptides	
		peptides.library <- matrix(-1, nrow=Nlib, ncol=nF)
		rdn.peptides <- replicate(maxL + maxR, sample.int(nAA, size = Nlib, replace = TRUE))
		rdn.peptides[, 1:(maxL - minL)] <- rdn.peptides[, 1:(maxL - minL)]*LD[sample.int(maxL-minL+1, size = Nlib, replace = TRUE), ] 
		rdn.peptides[, (maxL+maxR):(maxL+minR+1)] <- rdn.peptides[, (maxL+maxR):(maxL+minR+1)]*RD[sample.int(maxR-minR+1, size = Nlib, replace = TRUE),]
		rdn.peptides[rdn.peptides == 0] <- -1
		peptides.library[, (S.Pos - maxL + 1):(S.Pos + maxR)] <- rdn.peptides
		colnames(peptides.library) <- colnames(trainX)
		# train & predict
		prob <- Naive_Bayes(trainX, trainY, peptides.library, classlist, S.Pos, maxL, maxR, Gamma_0, Gamma_1, predIter = itr) 
		is_added <- FALSE
		# check the peptide to be added to recommendation set is not added before
		while(!is_added) {
			best_index <- which(prob==max(prob))
			add_pep <- peptides.library[best_index,]
			if(dim(unique(rbind(rec,add_pep)))[1] > nPep){
				rec <- rbind(rec, add_pep)
				nPep <- nPep + 1
				is_added <- TRUE
				add_train_peps <- data.frame(matrix(rep(add_pep, add_ins), add_ins, byrow = TRUE))
				colnames(add_train_peps) <- colnames(trainX)
				trainX <- rbind(trainX, add_train_peps)
				trainY <- c(trainY, rep(0, add_ins))	
			}
			else {
				peptides.library <- peptides.library[-best_index,]
				prob <- prob[-best_index]
			}
		}		
	}
	colnames(rec) <- colnames(X)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}

#Function: Generate a random peptide library with specified properties
# Inputs:
#       Nlib: size of this library
#       nAA:  # of AA groups, currently we use 8
#       nF:   # of features
#       maxL, maxR, minL, minR: max/min number of AAs in nterm/cterm
#       S.Pos: position of Serine
#       col_name: column name of training data
# Outputs:
#       peptides.library
gen_peptide_lib <- function(Nlib, nAA, nF, maxL, maxR, minL, minR, S.Pos, col_name) {
	LD <- rbind(upper.tri(matrix(1, maxL - minL, maxL - minL), diag = TRUE), rep(0, maxL - minL))
	RD <- rbind(upper.tri(matrix(1, maxR - minR, maxR - minR), diag = TRUE), rep(0, maxR - minR))
    # sample random peptides	
    peptides.library <- matrix(-1, nrow=Nlib, ncol=nF)
    rdn.peptides <- replicate(maxL + maxR, sample.int(nAA, size = Nlib, replace = TRUE))
    rdn.peptides[, 1:(maxL - minL)] <- rdn.peptides[, 1:(maxL - minL)] * LD[sample.int(maxL-minL+1, size = Nlib, replace = TRUE), ] 
    rdn.peptides[, (maxL+maxR):(maxL+minR+1)] <- rdn.peptides[, (maxL+maxR):(maxL+minR+1)]*RD[sample.int(maxR-minR+1, size = Nlib, replace = TRUE),]
    rdn.peptides[rdn.peptides == 0] <- -1
    peptides.library[, (S.Pos - maxL + 1):(S.Pos + maxR)] <- rdn.peptides
    colnames(peptides.library) <- col_name
    return (peptides.library)
}

# select the peptide to be added to recommendation set is not added before
select_new_recom <- function(trainX, peptides.library, prob) {
    unique_training_data <- unique(trainX)
    num_unique <- dim(unique_training_data)[1]
    while(length(prob)>0) {
        best_index <- which(prob==max(prob))
        add_pep <- peptides.library[best_index,]
        if((dim(unique(rbind(unique_training_data, add_pep)))[1] - num_unique) == 1){
            return (list('peptide'=add_pep, 'prob'=prob[best_index]))
        }
        else {
            peptides.library <- peptides.library[-best_index,]
            prob <- prob[-best_index]
        }
    }		
    return (rep(-10,1000))
}

GetRatioOldMethod <- function(matrix_x, vector_y, classlist, gamma_0, gamma_1) {
    alpha <- Dirichlet_Parameter(matrix_x, vector_y, classlist, Gamma_0 = gamma_0, Gamma_1 = gamma_1) 
    theta <- getTheta(alpha = alpha, classlist = classlist, Gamma_0 = gamma_0, Gamma_1 = gamma_1)
    return (as.matrix(theta$theta_1) / as.matrix(theta$theta_0))
}

GetRatioNewMethod <- function(classlist, matrix_x_label_prefer, vector_y_label_prefer, gamma_0_label_prefer, gamma_1_label_prefer, matrix_x_label_unprefer, vector_y_label_unprefer, gamma_0_label_unprefer, gamma_1_label_unprefer, matrix_x_unlabel, vector_y_unlabel, gamma_0_unlabel, gamma_1_unlabel) {
    alpha_label_prefer <- Dirichlet_Parameter(matrix_x_label_prefer, vector_y_label_prefer, classlist, Gamma_0 = gamma_0_label_prefer, Gamma_1 = gamma_1_label_prefer) 
    theta_label_prefer <- getTheta(alpha = alpha_label_prefer, classlist = classlist, Gamma_0 = gamma_0_label_prefer, Gamma_1 = gamma_1_label_prefer)

    alpha_label_unprefer <- Dirichlet_Parameter(matrix_x_label_unprefer, vector_y_label_unprefer, classlist, Gamma_0 = gamma_0_label_unprefer, Gamma_1 = gamma_1_label_unprefer) 
    theta_label_unprefer <- getTheta(alpha = alpha_label_unprefer, classlist = classlist, Gamma_0 = gamma_0_label_unprefer, Gamma_1 = gamma_1_label_unprefer)

    alpha_unlabel <- Dirichlet_Parameter(matrix_x_unlabel, vector_y_unlabel, classlist, Gamma_0 = gamma_0_unlabel, Gamma_1 = gamma_1_unlabel) 
    theta_unlabel <- getTheta(alpha = alpha_unlabel, classlist = classlist, Gamma_0 = gamma_0_unlabel, Gamma_1 = gamma_1_unlabel)
    return (as.matrix(theta_label_prefer$theta_1) / as.matrix(theta_label_prefer$theta_0) * as.matrix(theta_label_unprefer$theta_0) / as.matrix(theta_label_unprefer$theta_1) * as.matrix(theta_unlabel$theta_1) / as.matrix(theta_unlabel$theta_0))
}

MaxProbSearchMAPOld <- function(matrix_x, vector_y, classlist, serine_position, num_recom, max_left, max_right, min_left, min_right, gamma_0, gamma_1, add_ins) {
#================================================================================================================================================================================
#	An alternative version of maxP_search. The difference:
#		theta parameter is obtained by MAP estimation instead of Monte Carlo simulation.
#	
#================================================================================================================================================================================
	num_features <- dim(matrix_x)[2]
	rec <- c()	
	train_x <- matrix_x 
	train_y <- vector_y
	num_peptides <- 0
    count_repeated_recom <- 0

	while (num_peptides < num_recom) {		
        ratio <- GetRatioOldMethod(train_x, train_y, classlist, gamma_0, gamma_1)
		best_class <- as.numeric(apply(ratio, 2, which.max))
		length_left <- ceiling(runif(1, min = min_left-1, max = max_left))
		length_right  <- ceiling(runif(1, min = min_right-1, max = max_right))
		best_peptide <- rep(-1, num_features)
		best_peptide[(serine_position-length_left+1):(serine_position+length_right)] <- best_class[(serine_position-length_left+1):(serine_position+length_right)]
		if(isNew(train_x, best_peptide)){
			rec <- rbind(rec, best_peptide)
			num_peptides = num_peptides + 1
            print ("nth peptide")
            print (num_peptides)
		} else {
            count_repeated_recom <- count_repeated_recom + 1
            print ("repeated count")
            print (count_repeated_recom)
        }
        for (i in add_ins) {
            train_x <- rbind(train_x, best_peptide)
            train_y <- c(train_y, 0)
        }
	}
	colnames(rec) <- colnames(matrix_x)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}

MaxProbSearchMAPNew <- function(matrix_x_label_prefer, vector_y_label_prefer, matrix_x_label_unprefer, vector_y_label_unprefer, matrix_x_unlabel, vector_y_unlabel, classlist, serine_position, num_recom, max_left, max_right, min_left, min_right, gamma_0_label_prefer, gamma_1_label_prefer, gamma_0_label_unprefer, gamma_1_label_unprefer, gamma_0_unlabel, gamma_1_unlabel, add_ins) {
#================================================================================================================================================================================
#	An alternative version of maxP_search. The difference:
#		theta parameter is obtained by MAP estimation instead of Monte Carlo simulation.
#	
#================================================================================================================================================================================
	num_features <- dim(matrix_x_label_prefer)[2]
	rec <- c()	
	train_x_label_prefer <- matrix_x_label_prefer 
	train_y_label_prefer <- vector_y_label_prefer
	train_x_label_unprefer <- matrix_x_label_unprefer 
	train_y_label_unprefer <- vector_y_label_unprefer
	train_x_unlabel <- matrix_x_unlabel
	train_y_unlabel <- vector_y_unlabel
	num_peptides <- 0
    count_repeated_recom <- 0

	while (num_peptides < num_recom) {		
        ratio <- GetRatioNewMethod(classlist, train_x_label_prefer, train_y_label_prefer, gamma_0_label_prefer, gamma_1_label_prefer, train_x_label_unprefer, train_y_label_unprefer, gamma_0_label_unprefer, gamma_1_label_unprefer, train_x_unlabel, train_y_unlabel, gamma_0_unlabel, gamma_1_unlabel)
		best_class <- as.numeric(apply(ratio, 2, which.max))
		length_left <- ceiling(runif(1, min = min_left-1, max = max_left))
		length_right  <- ceiling(runif(1, min = min_right-1, max = max_right))
		best_peptide <- rep(-1, num_features)
		best_peptide[(serine_position-length_left+1):(serine_position+length_right)] <- best_class[(serine_position-length_left+1):(serine_position+length_right)]
		if(isNew(rbind(train_x_label_prefer, train_x_label_unprefer, train_x_unlabel), best_peptide)){
			rec <- rbind(rec, best_peptide)
			num_peptides = num_peptides + 1
            print ("nth peptide")
            print (num_peptides)
		} else {
            count_repeated_recom <- count_repeated_recom + 1
            print ("repeated count")
            print (count_repeated_recom)
        }
        for (i in add_ins) {
            train_x_label_prefer <- rbind(train_x_label_prefer, best_peptide)
            train_y_label_prefer <- c(train_y_label_prefer, 0)
            train_x_label_unprefer <- rbind(train_x_label_unprefer, best_peptide)
            train_y_label_unprefer <- c(train_y_label_unprefer, 1)
            train_x_unlabel <- rbind(train_x_unlabel, best_peptide)
            train_y_unlabel <- c(train_y_unlabel, 0)
        }
	}
	colnames(rec) <- colnames(matrix_x_label_prefer)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}

isNew <- function(collection, to_add) {
# Test if to_add is already existed in collection. We only compare to_add's non -1 entries so
# if collection has "1 2 3 4 5 6 7" and to_add is "-1 -1 3 4 5 -1 -1" then we still return false 
# Inputs:
#   collection: matrix with more than 1 row
#   to_add: vector
# Output:
#   bool
    to_add_reconstruct <- c()
    collection_reconstruct <- c()
    for (j in 1:length(to_add)) {
        if (to_add[j] != -1) {
            to_add_reconstruct <- c(to_add_reconstruct, to_add[j])
            collection_reconstruct <- cbind(collection_reconstruct, collection[,j])
        }
    }
    return ((dim(unique(rbind(collection_reconstruct, to_add_reconstruct)))[1] - dim(unique(collection_reconstruct))[1]) == 1)
}
		




#######################################################################################
ExpImprovement_par <- function(X, Y, newdata, classlist, nRep = 400, best.length = 20,
 prior.positive = 10**-4)
{
#================================================================================
#Function: ExpImprovement_par
#
#--------------------------------------------------------------------------------
#Description:
#    The parallel version of ExpImprovement. 
#        Given a set of peptides(newdata), computes the expected reduction in length 
#    of the shortest peptide known compared with current shortest length
#    (best.length).
#
#--------------------------------------------------------------------------------
#Input arguments:
#    train
#            A data matrix. Each row corresponds to a peptide and each column 
#            corresponds to a feature with the last column being the outcome
#            value.
#    newdata:
#            A data matrix whose rows correspond to peptides and columns to 
#            features. There shall be no outcome values.
#    classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    nRep:
#            Number of simulation replications.
#    best.length
#            Current shortest length of peptides working with both enzymes.
#    prior.positive
#            Prior distribution Pr(Y=1) where Y is the outcome value. The default 
#            10^-4. 
#
#--------------------------------------------------------------------------------
#Return objects:
#	 exp_reduc:
#        A list which contains:
#    improve
#            The desired expectation of reduction in length.
#    CI                 
#            The 95% percent confidence interval of exp.improve
#
#--------------------------------------------------------------------------------
    require(Rlab)
	nData <- dim(newdata)[1]
    #prob.hit: A binary vector. prob.hit[i] is the probability the ith peptide in 
	#          newdata is a hit(according to simulated posterior theta).
    prob.hit <- rep(0, nData)
	#is.hit: A binary vector. is.hit[i] = 1 if the ith peptide in newdata is a 
	#        hit. This vector is simulated according to  prob.hit.
	is.hit <- rep(0, nData)
	#reduction: A vector. reduction[i] is the reduction in the length compared
    #        	with best.length of the ith peptide in newdata if that peptide 
	#           is a hit
    #                     reduction[i] = 0 if is.hit[i] = 0
	#           reduction[i] = max(0,best.length-length(newdata[i])) 
	#           if is.hit[i] = 1
	
	#Calculate the length of all peptides in newdata
	peptide.length <- rowSums((newdata!=-1))
	#Initialize reduction
	reduction <- pmax(0,best.length - peptide.length)
	alpha <- Dirichlet_Parameter(X, Y, classlist, Gamma_0 = 1.5, Gamma_1 = 0.05)
	#max_reduction: A vector. max.reduction[i] = is the maximum reduction in the 
	#               length among all peptides in newdata in the ith simulation.
    max_reduction <- foreach(icount(nRep), .init = c(), .combine = append, 
			.packages = c('Rlab'), .export = c('getTheta_MC', 'NB_predict')) %dopar% {        
        theta <- getTheta_MC(alpha = alpha, classlist = classlist, Gamma_0 = 1.5, Gamma_1 = 0.05)
		data_for_cal <- newdata
		data_for_cal[newdata == -1] <- 9
		prob.hit <- NB_predict(data_for_cal, theta, maxL = 9, maxR = 10, prior.positive = prior.positive)
        #Simulate is.hit according to prob.hit
		is.hit <- rbern(nData, prob.hit)
		max(reduction*is.hit)
    }
    improve <- mean(max_reduction)
	CI <- c(improve-sd(max_reduction)*qnorm(0.975)/sqrt(nRep), improve+sd(max_reduction)*qnorm(0.975)/sqrt(nRep))
	exp_reduc <- list("improve" = improve, "CI" = CI) 
    return(exp_reduc)   
}





##############################################################################################################################
ProbImprovement_par <- function(train, newdata, classlist, nRep, best.length = 11,
 prior.positive = 10**-4)
{
#================================================================================
#Function: ProbImprovement_par
#
#--------------------------------------------------------------------------------
#Description:
#    The parallel version of ProbImprovement. 
#        Computes the probability that at least one peptide with length shorter 
#    than previous best in newdata is a hit.
#
#--------------------------------------------------------------------------------
#Input arguments:
#    train
#            A data matrix. Each row corresponds to a peptide and each column 
#            corresponds to a feature with the last column being the outcome
#            value.
#    newdata:
#            A data matrix whose rows correspond to peptides and columns to 
#            features. There shall be no outcome values.
#    classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    nRep:
#            Number of simulation replications.
#    best.length
#            Current shortest length of peptides working with both enzymes.
#    prior.positive
#            Prior distribution Pr(Y=1) where Y is the outcome value. The default 
#            10^-4. 
#
#--------------------------------------------------------------------------------
#Return objects:
#    prob
#        A list which contains:
#    improve
#            The desired expected reduction. 
#    CI                
#            The 95% confidence interval of the desired probability.
#--------------------------------------------------------------------------------
	require(Rlab)
	nData <- dim(newdata)[1]
    	#prob.hit: A binary vector. prob.hit[i] is the probability the ith peptide in 
	#          newdata is a hit(according to simulated posterior theta).
    	prob.hit <- rep(0, nData)
	#is.hit: A binary vector. is.hit[i] = 1 if the ith peptide in newdata is a 
	#        hit, this vector is simulated according to  prob.hit
	is.hit <- rep(0, nData)
	#isShorter: A vector. isShorter[i] is the indicator of the ith peptide in 
	#           newdata being shorter than the best previous peptide.
	#Calculate the length of all peptides in newdata
	peptide.length <- rowSums(!is.na(newdata))
	is.shorter <- as.numeric(peptide.length < best.length)
    #is.found: A binary vector. In the ith simulation, if at least one of the 
	#          peptides in newdata is a hit and is shorter than best.length, 
	#      	   is.found[i] = 1, otherwise 0.
    is.found <- rep(0, nRep)
	alpha <- Dirichlet_Parameter(train, classlist)
    is.found <- foreach(icount(nRep), .combine = append, .init = c(), .packages = c('Rlab'),
	    .export = c('NB_predict','getTheta_MC')) %dopar% {        
        theta <- getTheta_MC(alpha = alpha, classlist = classlist)
		prob.hit <- NB_predict(newdata, theta, prior.positive = prior.positive)
        #Simulate is.hit according to prob.hit
		is.hit <- rbern(nData, prob.hit)
		as.numeric(any(is.hit*is.shorter > 0))
    }
    improve <- mean(is.found)
	CI <- c(improve-sd(is.found)*qnorm(0.975)/sqrt(nRep), improve+sd(is.found)*qnorm(0.975)/sqrt(nRep))
	prob <- list("improve" = improve, "CI" = CI)
    return(prob)   
}
