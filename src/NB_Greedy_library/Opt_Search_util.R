maxP_search <- function(X, Y, classlist, S.Pos, Nrec, itr, Nlib, maxL, maxR, minL, minR, Gamma_0, Gamma_1, add_ins) 
{
#================================================================================================================================================================================
#Function: maxP_search
#
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Description:
#    	Generate a set of recommendations. To add a new recommendation to the set, Use the greedy heuristic, pick a peptide to maximize probability of improvement among a
#       randomly generated library of peptides. 
#
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Input arguments:
#	X
#		The matrix of training samples. Each row is a feature vector of a peptide.
#	Y
#		The vector of training labels.
#	classlist
#             	The vector specifying the class each amino-acid belongs to.  	
#	S.Pos
#		position of serene of a peptide IN THE MODEL, this parameter is determined by the model instead of training data or recommendations to be generated.
#	Nrec
# 		Size of the set of recommendations.
# 	itr
#		Iterations needed for calculation the probability of being hit using Monte Carlo simulation.
#	Nlib
# 		Size of the randomly generated library of peptides in each step of the greedy heuristic.
#	maxL, maxR, minL, minR
#	 	Maximum/minimum number of peptides to the left/right of serene for all the recommendations to be generated.
#	Gamma_0/Gamma_1:
#		The gamma parameters for computing posterior alpha parameters.
#	add_ins
#		The number of replications of a recommendation to be added into training set as non-hits after it is generated by the greedy heuristic.
#	
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Return objects:
#    	rec
#		a matrix with each row being the feature vector of a recommended peptide.  
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	nF <- dim(X)[2]
	nAA <- length(unique(as.numeric(classlist)))
	rec <- c()
	trainX <- X
	trainY <- Y	
	nPep <- 0

	#LD, RD are used for generating random peptide library
	LD <- rbind(upper.tri(matrix(1, maxL - minL, maxL - minL), diag = TRUE), rep(0, maxL - minL))
	RD <- rbind(upper.tri(matrix(1, maxR - minR, maxR - minR), diag = TRUE), rep(0, maxR - minR))
	while(nPep < Nrec) {	
		L <- ceiling(runif(1, min = minL-1, max = maxL))
		R <- ceiling(runif(1, min = minR-1, max = maxR))
		# sample random peptides	
		peptides.library <- matrix(-1, nrow=Nlib, ncol=nF)
		rdn.peptides <- replicate(maxL + maxR, sample.int(nAA, size = Nlib, replace = TRUE))
		rdn.peptides[, 1:(maxL - minL)] <- rdn.peptides[, 1:(maxL - minL)]*LD[sample.int(maxL-minL+1, size = Nlib, replace = TRUE), ] 
		rdn.peptides[, (maxL+maxR):(maxL+minR+1)] <- rdn.peptides[, (maxL+maxR):(maxL+minR+1)]*RD[sample.int(maxR-minR+1, size = Nlib, replace = TRUE),]
		rdn.peptides[rdn.peptides == 0] <- -1
		peptides.library[, (S.Pos - maxL + 1):(S.Pos + maxR)] <- rdn.peptides
		colnames(peptides.library) <- colnames(trainX)
		# train & predict
		prob <- Naive_Bayes(trainX, trainY, peptides.library, classlist, S.Pos, maxL, maxR, Gamma_0, Gamma_1, predIter = itr) 
		is_added <- FALSE
		# check the peptide to be added to recommendation set is not added before
		while(!is_added) {
			best_index <- which(prob==max(prob))
			add_pep <- peptides.library[best_index,]
			if(dim(unique(rbind(rec,add_pep)))[1] > nPep){
				rec <- rbind(rec, add_pep)
				nPep <- nPep + 1
				is_added <- TRUE
				add_train_peps <- data.frame(matrix(rep(add_pep, add_ins), add_ins, byrow = TRUE))
				colnames(add_train_peps) <- colnames(trainX)
				trainX <- rbind(trainX, add_train_peps)
				trainY <- c(trainY, rep(0, add_ins))	
			}
			else {
				peptides.library <- peptides.library[-best_index,]
				prob <- prob[-best_index]
			}
		}		
	}
	colnames(rec) <- colnames(X)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}

#Function: Generate a random peptide library with specified properties
# Inputs:
#       Nlib: size of this library
#       nAA:  # of AA groups, currently we use 8
#       nF:   # of features
#       maxL, maxR, minL, minR: max/min number of AAs in nterm/cterm
#       S.Pos: position of Serine
#       col_name: column name of training data
# Outputs:
#       peptides.library
gen_peptide_lib <- function(Nlib, nAA, nF, maxL, maxR, minL, minR, S.Pos, col_name) {
	LD <- rbind(upper.tri(matrix(1, maxL - minL, maxL - minL), diag = TRUE), rep(0, maxL - minL))
	RD <- rbind(upper.tri(matrix(1, maxR - minR, maxR - minR), diag = TRUE), rep(0, maxR - minR))
    # sample random peptides	
    peptides.library <- matrix(-1, nrow=Nlib, ncol=nF)
    rdn.peptides <- replicate(maxL + maxR, sample.int(nAA, size = Nlib, replace = TRUE))
    rdn.peptides[, 1:(maxL - minL)] <- rdn.peptides[, 1:(maxL - minL)] * LD[sample.int(maxL-minL+1, size = Nlib, replace = TRUE), ] 
    rdn.peptides[, (maxL+maxR):(maxL+minR+1)] <- rdn.peptides[, (maxL+maxR):(maxL+minR+1)]*RD[sample.int(maxR-minR+1, size = Nlib, replace = TRUE),]
    rdn.peptides[rdn.peptides == 0] <- -1
    peptides.library[, (S.Pos - maxL + 1):(S.Pos + maxR)] <- rdn.peptides
    colnames(peptides.library) <- col_name
    return (peptides.library)
}

# select the peptide to be added to recommendation set is not added before
select_new_recom <- function(prev_recom_list, peptides.library, prob, pep_idx) {
    while(length(prob)>0) {
        best_index <- which(prob==max(prob))
        add_pep <- peptides.library[best_index,]
        if((pep_idx==1) || (dim(unique(rbind(prev_recom_list,add_pep)))[1]==pep_idx)){
            return (add_pep)
        }
        else {
            peptides.library <- peptides.library[-best_index,]
            prob <- prob[-best_index]
        }
    }		
}


maxP_search_MAP <- function(X, Y, classlist, S.Pos, Nrec, itr = 500, Nlib = 1e5, maxL, maxR, minL, minR, Gamma_0 = 1, Gamma_1 = 1, add_ins = 1) 
{
#================================================================================================================================================================================
#	An alternative version of maxP_search. The difference:
#		theta parameter is obtained by MAP estimation instead of Monte Carlo simulation.
#	
#================================================================================================================================================================================
	nF <- dim(X)[2]
	nAA <- length(unique(as.numeric(classlist)))
	rec <- c()	
	trainX <- X
	trainY <- Y
	nPep <- 0

	while (nPep < Nrec) {		
		alpha <- Dirichlet_Parameter(trainX, trainY, classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1) 
		theta <- getTheta(alpha = alpha, classlist = classlist, Gamma_0 = Gamma_0, Gamma_1 = Gamma_1)
		ratio <- as.matrix(theta$theta_1) / as.matrix(theta$theta_0)
		best.class <- as.numeric(apply(ratio, 2, which.max))
		#for (i in 1:nF) {
		#	best.class[i] <- which.max(ratio[,i])
		#}
		L <- ceiling(runif(1, min = minL-1, max = maxL))
		R <- ceiling(runif(1, min = minR-1, max = maxR))
		best.peptide <- rep(-1, nF)
		best.peptide[(S.Pos-L+1):(S.Pos+R)] <- best.class[(S.Pos-L+1):(S.Pos+R)]
		if(dim(unique(rbind(rec,best.peptide)))[1] > nPep){
			rec <- rbind(rec, best.peptide)
			nPep = nPep + 1
		}
		add_train_peps <- data.frame(matrix(rep(best.peptide, add_ins), add_ins, byrow = TRUE))
		colnames(add_train_peps) <- colnames(trainX)
		trainX <- rbind(trainX, add_train_peps)
		trainY <- c(trainY, rep(0,add_ins))	
	}
	colnames(rec) <- colnames(X)
	rownames(rec) <- c(1:dim(rec)[1])
	return (rec)
}
		




#######################################################################################
ExpImprovement_par <- function(X, Y, newdata, classlist, nRep = 400, best.length = 20,
 prior.positive = 10**-4)
{
#================================================================================
#Function: ExpImprovement_par
#
#--------------------------------------------------------------------------------
#Description:
#    The parallel version of ExpImprovement. 
#        Given a set of peptides(newdata), computes the expected reduction in length 
#    of the shortest peptide known compared with current shortest length
#    (best.length).
#
#--------------------------------------------------------------------------------
#Input arguments:
#    train
#            A data matrix. Each row corresponds to a peptide and each column 
#            corresponds to a feature with the last column being the outcome
#            value.
#    newdata:
#            A data matrix whose rows correspond to peptides and columns to 
#            features. There shall be no outcome values.
#    classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    nRep:
#            Number of simulation replications.
#    best.length
#            Current shortest length of peptides working with both enzymes.
#    prior.positive
#            Prior distribution Pr(Y=1) where Y is the outcome value. The default 
#            10^-4. 
#
#--------------------------------------------------------------------------------
#Return objects:
#	 exp_reduc:
#        A list which contains:
#    improve
#            The desired expectation of reduction in length.
#    CI                 
#            The 95% percent confidence interval of exp.improve
#
#--------------------------------------------------------------------------------
    require(Rlab)
	nData <- dim(newdata)[1]
    #prob.hit: A binary vector. prob.hit[i] is the probability the ith peptide in 
	#          newdata is a hit(according to simulated posterior theta).
    prob.hit <- rep(0, nData)
	#is.hit: A binary vector. is.hit[i] = 1 if the ith peptide in newdata is a 
	#        hit. This vector is simulated according to  prob.hit.
	is.hit <- rep(0, nData)
	#reduction: A vector. reduction[i] is the reduction in the length compared
    #        	with best.length of the ith peptide in newdata if that peptide 
	#           is a hit
    #                     reduction[i] = 0 if is.hit[i] = 0
	#           reduction[i] = max(0,best.length-length(newdata[i])) 
	#           if is.hit[i] = 1
	
	#Calculate the length of all peptides in newdata
	peptide.length <- rowSums((newdata!=-1))
	#Initialize reduction
	reduction <- pmax(0,best.length - peptide.length)
	alpha <- Dirichlet_Parameter(X, Y, classlist, Gamma_0 = 1.5, Gamma_1 = 0.05)
	#max_reduction: A vector. max.reduction[i] = is the maximum reduction in the 
	#               length among all peptides in newdata in the ith simulation.
    max_reduction <- foreach(icount(nRep), .init = c(), .combine = append, 
			.packages = c('Rlab'), .export = c('getTheta_MC', 'NB_predict')) %dopar% {        
        theta <- getTheta_MC(alpha = alpha, classlist = classlist, Gamma_0 = 1.5, Gamma_1 = 0.05)
		data_for_cal <- newdata
		data_for_cal[newdata == -1] <- 9
		prob.hit <- NB_predict(data_for_cal, theta, maxL = 9, maxR = 10, prior.positive = prior.positive)
        #Simulate is.hit according to prob.hit
		is.hit <- rbern(nData, prob.hit)
		max(reduction*is.hit)
    }
    improve <- mean(max_reduction)
	CI <- c(improve-sd(max_reduction)*qnorm(0.975)/sqrt(nRep), improve+sd(max_reduction)*qnorm(0.975)/sqrt(nRep))
	exp_reduc <- list("improve" = improve, "CI" = CI) 
    return(exp_reduc)   
}





##############################################################################################################################
ProbImprovement_par <- function(train, newdata, classlist, nRep, best.length = 11,
 prior.positive = 10**-4)
{
#================================================================================
#Function: ProbImprovement_par
#
#--------------------------------------------------------------------------------
#Description:
#    The parallel version of ProbImprovement. 
#        Computes the probability that at least one peptide with length shorter 
#    than previous best in newdata is a hit.
#
#--------------------------------------------------------------------------------
#Input arguments:
#    train
#            A data matrix. Each row corresponds to a peptide and each column 
#            corresponds to a feature with the last column being the outcome
#            value.
#    newdata:
#            A data matrix whose rows correspond to peptides and columns to 
#            features. There shall be no outcome values.
#    classlist
#             A matrix specifying the mapping between each amino-acids and the 
#             class it belongs to.
#    nRep:
#            Number of simulation replications.
#    best.length
#            Current shortest length of peptides working with both enzymes.
#    prior.positive
#            Prior distribution Pr(Y=1) where Y is the outcome value. The default 
#            10^-4. 
#
#--------------------------------------------------------------------------------
#Return objects:
#    prob
#        A list which contains:
#    improve
#            The desired expected reduction. 
#    CI                
#            The 95% confidence interval of the desired probability.
#--------------------------------------------------------------------------------
	require(Rlab)
	nData <- dim(newdata)[1]
    	#prob.hit: A binary vector. prob.hit[i] is the probability the ith peptide in 
	#          newdata is a hit(according to simulated posterior theta).
    	prob.hit <- rep(0, nData)
	#is.hit: A binary vector. is.hit[i] = 1 if the ith peptide in newdata is a 
	#        hit, this vector is simulated according to  prob.hit
	is.hit <- rep(0, nData)
	#isShorter: A vector. isShorter[i] is the indicator of the ith peptide in 
	#           newdata being shorter than the best previous peptide.
	#Calculate the length of all peptides in newdata
	peptide.length <- rowSums(!is.na(newdata))
	is.shorter <- as.numeric(peptide.length < best.length)
    #is.found: A binary vector. In the ith simulation, if at least one of the 
	#          peptides in newdata is a hit and is shorter than best.length, 
	#      	   is.found[i] = 1, otherwise 0.
    is.found <- rep(0, nRep)
	alpha <- Dirichlet_Parameter(train, classlist)
    is.found <- foreach(icount(nRep), .combine = append, .init = c(), .packages = c('Rlab'),
	    .export = c('NB_predict','getTheta_MC')) %dopar% {        
        theta <- getTheta_MC(alpha = alpha, classlist = classlist)
		prob.hit <- NB_predict(newdata, theta, prior.positive = prior.positive)
        #Simulate is.hit according to prob.hit
		is.hit <- rbern(nData, prob.hit)
		as.numeric(any(is.hit*is.shorter > 0))
    }
    improve <- mean(is.found)
	CI <- c(improve-sd(is.found)*qnorm(0.975)/sqrt(nRep), improve+sd(is.found)*qnorm(0.975)/sqrt(nRep))
	prob <- list("improve" = improve, "CI" = CI)
    return(prob)   
}
