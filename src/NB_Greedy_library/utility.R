Recom_Generation <- function(training_file, classfile, outcome_name, nL, nR, S.Pos, prior.positive = 1e-4, itr = 500, Nrec, Nlib, maxL, maxR, minL, minR, Gamma_0 = 1000, Gamma_1
			     = 0.05, add_ins = 1, use_map = 0, out_file)
{
#================================================================================================================================================================================#Function: Recom_Generation
#
#===============================================================================================================================================================================
#Description:	
#	Given training data, this function generates a set of recommendations in the following way:
#		(1) Generate a set of recommending feature vectors using the greedy heuristic, maximizing probability of improvement at each step.
#		(2) For each recommending feature vector, at each position, choose uniformly from amino-acids that belongs to the class at that position
#
#================================================================================================================================================================================#Input	Arguments:
#	training_file:
#		The file containing training data. It is a string of the filename includinng its full path. The file MUST be arranged in this way:
#		A csv file, comma separated, with n+2 columns and each row corresponds to a peptide. The (n+2) columns are:
#		Y_1	...	Y_n	cterm	nterm
#		where Y_1...Y_n are names of n different labels(e.g. 'AcpH' or 'Type_1'), each takes value in {0,1}, and cterm/nterm are parts of peptide to the left/right of
#       	the serene(both in the form a string of amino-acids)	
#	classfile
#		A string of the name(including full path) of the class file: a two-lines csv file that contains the mapping between amino-acids and classes they belon to:
#		A	R	N	...
#		5	4	2	...
#	outcome_name
#		A string. The name of the outcome value.	
#	nL, nR
#		Number of amino-acids to the left/right of the serene to put into the feature vector by the model.
#	S.Pos
#		position of serene of a peptide IN THE MODEL, this parameter is determined by the model instead of training data or recommendations to be generated.
#    	prior.positive
#            	Prior probability  Pr(Y=1). Y is the label, default 10^-4.
#	Nrec
# 		Size of the set of recommendations.
# 	itr
#		Iterations needed for calculation the probability of being hit using Monte Carlo simulation.
#	Nlib
# 		Size of the randomly generated library of peptides in each step of the greedy heuristic.
#	maxL, maxR, minL, minR
#	 	Maximum/minimum number of peptides to the left/right of serene for all the recommendations to be generated.
#	Gamma_0/Gamma_1:
#		The gamma parameters for computing posterior alpha parameters.
#	add_ins
#		The number of replications of a recommendation to be added into training set as non-hits after it is generated by the greedy heuristic.
#	use_map
#		logical. If use_map = 1, when generating recommendations using greedy heuristic, the theta parameter in each step is MAP estimated, otherwise Monte Carlo
#		simulated.
#	out_file:
#		The name(including the full path) of output file. A csv file and a plane text file with this name will be generated to record the recommendations generated.
#			
#================================================================================================================================================================================
#Return object:
#	No objects are returned. Two files will be created in the path specified in out_file:
#		(1) A csv file, with 4 columns:
#			nterm	cterm	AAseq		prob
#		e.g.	AD	LEWMD	ADSLEWMD	1
#		AAseq is the full sequence of amino-acids of the peptide, prob is the probability of being hit.
#		(2) A plane text file, each line is the full sequence of amino-acids of a peptide.
#	
#================================================================================================================================================================================
	data_org <- data.frame(read.csv(training_file, header = T, as.is = T, sep =','))
	AAclass <- data.frame(read.csv(classfile, header = T, as.is = T, sep = ','))
	S.Pos <- nL
	train_data <- getFeatures(data_org, AAclass, nL, nR)
	X <- train_data[,1:(nL+nR)]
	Y <- train_data[,outcome_name]
	recom <- c()
	if(use_map) {
		recom <- maxP_search_MAP(X, Y, AAclass, S.Pos, Nrec, itr, Nlib, maxL, maxR, minL, minR, Gamma_0, Gamma_1, add_ins)
	}
	else {
		recom <- maxP_search(X, Y, AAclass, S.Pos, Nrec, itr, Nlib, maxL, maxR, minL, minR, Gamma_0, Gamma_1, add_ins)
	}
	pred_prob <- Naive_Bayes(X, Y, recom, AAclass, S.Pos, maxL, maxR, Gamma_0, Gamma_1, prior.positive, itr)
	writePep(recom, S.Pos, pred_prob, AAclass, out_file)
}





#################################################################################################################################################################################
writePep <- function(newPep, S.Pos, pred_prob, classlist, out_file) 
{
#================================================================================================================================================================================
#Function: writePep
#
#================================================================================================================================================================================
#Description
#	This function takes a matrix as input, each row is the feature vector of a peptide. It generates the amino-acid at each position uniformly according to classlist, and
#      	write generated peptides into a csv file and a text file named by out_file. 
#
#================================================================================================================================================================================
#Input Arguments
#	newPep
#		The matrix of peptides to write, of which each row is the feature vector of the peptide.
#	S.Pos
#		The position of serene in each feature vector. S.Pos is determined by the model, i.e., the theta matrix, if, for the model, there're at most nL amino-acids to 
#		the left of serene(i.e., there're nL theta parameters to the left of serene), then S.Pos = nL.	
#	pred_prob
#		The vector of the predicted probability of being hit of all peptides in newPep.
#	classlist
#		The vector specifying the class each amino acid belongs to.    
#	out_file:
#		The name(including the full path) of output file. A csv file and a plane text file with this name will be generated to record the recommendations generated.
#
#================================================================================================================================================================================#Return objects
##	No objects are returned. Two files will be created in the path specified in out_file:
#		(1) A csv file, with 4 columns:
#			nterm	cterm	AAseq		prob
#		e.g.	AD	LEWMD	ADSLEWMD	1
#		AAseq is the full sequence of amino-acids of the peptide, prob is the predicted probability of being hit.
#		(2) A plane text file, each line is the full sequence of amino-acids of a peptide.
#	
#================================================================================================================================================================================
	#Generate the amino-acid on each position 
	nPep <- dim(newPep)[1]
	nF <- dim(newPep)[2]
	pepTable <- c()
	for(i in 1:nPep) {
		nTerm <- c()
		for(j in 1:S.Pos) {
			if( newPep[i,j] != -1 ) {
				AApool <- colnames(classlist)[which(classlist == newPep[i,j])]
				AA <- AApool[sample.int(length(AApool), size = 1)]
				nTerm <- paste(nTerm, AA, sep = "")
			}
		}
		cTerm <- c()
		for(j in (S.Pos+1):nF) {
			if( newPep[i,j] != -1 ) {
				AApool <- colnames(classlist)[which(classlist == newPep[i,j])]
				AA <- AApool[sample.int(length(AApool), size = 1)]
				cTerm <- paste(cTerm, AA, sep = "")
			}
		}
		AAseq <- paste(nTerm, 'S', cTerm, sep = "")
		pepTable <- rbind(pepTable, c(nTerm, cTerm, AAseq))
	}
	pepTable <- cbind(pepTable, pred_prob)
	colnames(pepTable) <- c('nterm', 'cterm', 'AAseq', 'prob')
	#Sort peptides according to their probabilities of being hits
	pepTable <- pepTable[order(pred_prob, decreasing = TRUE),]
	rownames(pepTable) <- c(1:nPep)
	pepTable <- as.data.frame(pepTable, stringsAsFactors = FALSE)	
	write.csv(pepTable, paste(out_file,'.csv',sep=''))
	#pepList <- c()
	#for( i in 1:nPep ) {
	#	pep <- paste(pepTable[i,'nTerm'], 'S', pepTable[i, 'cTerm'], sep = "")
	#	pepList <- rbind(pepList, pep)
	#}
	fileConn<-file(paste(out_file,'.txt',sep=''))
	writeLines(pepTable$AAseq, fileConn)
	close(fileConn)	
}




#################################################################################################################################################################################
muteGen <- function(data_file, class_file, outcome_name, nMute = c(2:4), nPep, pred_prob_param, out_file)
{
#================================================================================================================================================================================
#Function: muteGen
#
#================================================================================================================================================================================
#Description
#	Given a set of peptides, this function mutates the amino-acid at some positions of some peptides in this set to create a new set of recommendations.
#
#===============================================================================================================================================================================
#Input Arguments
#	data_file
#		The file containing the peptides to mutate. It is a string of the filename includinng its full path. The file MUST be arranged in this way:
#		A csv file, comma separated, with n+2 columns and each row corresponds to a peptide. The (n+2) columns are:
#		Y_1	...	Y_n	cterm	nterm
#		where Y_1...Y_n are names of n different labels(e.g. 'AcpH' or 'Type_1'), each takes value in {0,1}, and cterm/nterm are parts of peptide to the left/right of
#       	the serene(both in the form a string of amino-acids)	
#	classfile
#		A string of the name(including full path) of the class file: a two-lines csv file that contains the mapping between amino-acids and classes they belon to:
#		A	R	N	...
#		5	4	2	...
#	outcome_name
#		A string. The name of the outcome value.
#	nMute
#		A length-2 vector, each time to mutate an existing peptide, the number of positions to mutate is determined by uniformly picking a number from the range
#		determined by nMute
#	nPep
#		Number of new peptides to generate.
#	pred_prob_param
#		a vector of parameters to predict the probability of being hit for mutated peptides. It should be arranged in this way:
#			c(training_file, nL, nR, S.Pos, Gamma_0, Gamma_1, prior.positive, itr)
#		see description of each parameter in the description of function 'Recom_Generation'.
#		This parameter could be left unspecified. If unspecified, the 'prob' column of the out put csv file(see description below) will be an empty column.
#	out_file:
#		The name(including the full path) of output file. A csv file and a plane text file with this name will be generated to record the recommendations generated.
#			
#================================================================================================================================================================================
#Return object:
#	No objects are returned. Two files will be created in the path specified in out_file:
#		(1) A csv file, with 4 columns:
#			nterm	cterm	AAseq		prob
#		e.g.	AD	LEWMD	ADSLEWMD	1
#		AAseq is the full sequence of amino-acids of the peptide, prob is the probability of being hit.
#		(2) A plane text file, each line is the full sequence of amino-acids of a peptide.
#	
#================================================================================================================================================================================
	AAclass <- data.frame(read.csv(class_file, header = T, as.is = T, sep = ','))
	pep_lib <- data.frame(read.csv(data_file, header = T, as.is = T, sep = ','))
	pep_lib <- pep_lib[pep_lib[,which(colnames(pep_lib) == outcome_name)]==1,]
	nlib <- dim(pep_lib)[1]
	ncol <- dim(pep_lib)[2]
	nAA <- length(unique(as.numeric(AAclass)))
	mutants <- c()
	for(i in 1:nPep) {
		#id: the index of the peptide in pep_lib to mutate
    		id <- sample.int(nlib, size = 1)
		#nPos: number of positions to mutate
		nPos <- sample(nMute, size = 1)
		#L: length of chosen peptide
		L <- nchar(pep_lib$nterm[id]) + nchar(pep_lib$cterm[id])
		pos <- sample.int(L, size = nPos)
		nterm <- unlist(strsplit(pep_lib[id, ncol-1], split = ""))
		cterm <- unlist(strsplit(pep_lib[id, ncol], split = ""))
		for (j in 1:nPos) {
			if(pos[j] <= nchar(pep_lib$nterm[id])) {
				newC <- sample(c(1:nAA)[-as.numeric(AAclass[colnames(AAclass) == nterm[pos[j]]])], size = 1)
				newAA <- sample(colnames(AAclass)[AAclass == newC], size = 1)
				nterm[pos[j]] <- newAA
			}
			else {
				newC <- sample(c(1:nAA)[-as.numeric(AAclass[colnames(AAclass) == cterm[pos[j]-nchar(pep_lib$nterm[id])]])], size = 1)
				newAA <- sample(colnames(AAclass)[AAclass == newC], size = 1)
				cterm[pos[j]-nchar(pep_lib$nterm[id])] <- newAA
			}
		}	
		nterm <- paste(nterm, collapse = "")
		cterm <- paste(cterm, collapse = "")
		AAseq <- paste(nterm, 'S', cterm, sep = "")
		mutants  <- rbind(mutants, c(nterm, cterm, AAseq))
	}
	mutants <- cbind(mutants, rep('', nPep))
	colnames(mutants) <- c('nterm','cterm','AAseq','prob')
	#predict the probability of being hit for the peptides in mutants if pred_prob_param is specified
	mutants <- as.data.frame(mutants, stringsAsFactors = FALSE)
	if(!missing(pred_prob_param))
	{
		train_file <- pred_prob_param[1]
		nL <- as.numeric(pred_prob_param[2])
		nR <- as.numeric(pred_prob_param[3])
		S.Pos <- as.numeric(pred_prob_param[4])
		Gamma_0 <- as.numeric(pred_prob_param[5])
		Gamma_1 <- as.numeric(pred_prob_param[6])
		prior.positive <- as.numeric(pred_prob_param[7])
		itr <- as.numeric(pred_prob_param[8])

		mut_fea <- getFeatures(mutants[,1:2], AAclass, nL, nR)
		train_data <- data.frame(read.csv(train_file, header = T, as.is = T, sep = ','))
		train_data <- getFeatures(train_data, AAclass, nL, nR)
		trainX <- train_data[,1:(nL+nR)]
		trainY <- train_data[, outcome_name]
		maxL <- max(nchar(mutants$nterm))
		maxR <- max(nchar(mutants$cterm))
		pred_prob <- Naive_Bayes(trainX, trainY, mut_fea, AAclass, S.Pos, maxL, maxR, Gamma_0, Gamma_1, prior.positive, itr) 
		mutants$prob <- pred_prob
	}
	#Sort peptides according to their probabilities of being hits
	mutants <- mutants[order(pred_prob, decreasing = TRUE),]
	rownames(mutants) <- c(1:nPep)
	write.csv(mutants, paste(out_file,'.csv',sep=''))
	#pepList <- c()
	#for( i in 1:nPep ) {
	#	pep <- paste(pepTable[i,'nTerm'], 'S', pepTable[i, 'cTerm'], sep = "")
	#	pepList <- rbind(pepList, pep)
	#}
	fileConn<-file(paste(out_file,'.txt',sep=''))
	writeLines(mutants$AAseq, fileConn)
	close(fileConn)	
}




#################################################################################################################################################################################
crossValid_ROC <- function(prob_file, label_file, outcome_name, out_file)
{
#================================================================================================================================================================================
#Function: crossValid_ROC
#
#================================================================================================================================================================================#Input Arguments
#	prob_file
#		The file containing the predicted probability of being hit. This is the file generated by data_collect.sh
#	label_fiel
#		The file containing actual labels. USE TRAINING DATA FILE AS label_file.
#	outcome_name
#		A string. The name of the outcome value.
#	out_file
#		The name(including the full path) of the file of the ROC plot.
#
#================================================================================================================================================================================
#Return Objects:
#	No objects will be returned. A pdf plot named by out_file will be created in the path specified by out_file.
#
#================================================================================================================================================================================
	Y <- data.frame(read.csv(label_file, header = T, as.is = T, sep = ','))[,outcome_name]	
	file_conn <- file(prob_file, 'r')
	prob <- readLines(file_conn)
	close(file_conn)
	ROC_plot(prob, Y, out_file)
}





#################################################################################################################################################################################
ROC_plot <- function(prob, Y, out_file) 
{
#================================================================================================================================================================================
#Function: ROC_plot
#
#================================================================================================================================================================================#Description:
#	This function plots the ROC curve given a vector of predicted probability.
#
#================================================================================================================================================================================
#Input Arguments
#	prob
#		The vector of predicted probability. 
#	Y
#		A vector of actual labels. The order of labels in Y must be in corresponding with the order of probabilities in prob_file
#	out_file
#		The name(including the full path) of the file of the ROC plot.
#
#================================================================================================================================================================================
#Return Objects:
#	No objects will be returned. A pdf plot named by out_file will be created in the path specified by out_file.
#
#================================================================================================================================================================================
	FPR <- rep(-1, length(prob))
	TPR <- rep(-1, length(prob))
	thresholds <- sort(prob)
	for( i in 1:length(prob) ) {
		threshold <- thresholds[i]
		label <- rep(0, length(prob))
		for( j in 1:length(prob) ){
			if(prob[j] >= threshold) {
				label[j] <- 1 }
		}
		FPR[i] <- sum((Y==0)&(label==1))/sum(Y==0)
		TPR[i] <- sum((Y==1)&(label==1))/sum(Y==1)
	}
	pdf(paste(out_file, '.pdf',sep=''))
	plot(x = FPR, y = TPR, type = 'l', xlim = c(0,1), ylim = c(0,1), xlab = "false positive rate", ylab = "true positive rate")
	Table <- cbind(FPR, TPR)
	colnames(Table) <- c("FPR", "TPR")
	write.csv(Table, paste(out_file,'.csv', sep=""))
	dev.off()
}


