# Author: Tom Fei
# Created: 06.06.2015
# Local search algorithm
# NOTE: Run generate_recom_set.R before proceeding
# NOTE: The previous version of this code uses the
#       pre-refactor code base and does NOT test
#       uniqueness of each row of the recommendation
#       set S while updating the set. It is located 
#       in the archive_code directory.

set.seed(1)

root <- "~/repos/peptide-catalysis/src/"
source(paste0(root, "core/dependency.R"))
ResolveDependency(root)

# source("generate_recom_set.R")
source("prob_improv_of_set.R")

S <- recom.set  # recom.set is generated by generate_recom_set.R
X <- dataset$feature
Y <- dataset$data[, 'type1']
train.X <- X[Y != -1, ]
train.Y <- Y[Y != -1]
Y <- c(train.Y, rep(0, nrow(S) - 1))
PI.ITER <- 100
prob.improv.S <- rep(-1, PI.ITER)
rdm.pos.vec <- floor(runif(PI.ITER, 1, nrow(S))) 

for (i in 1:PI.ITER) {
  print(sprintf("iter #%d", i))
  ptm.0 <- proc.time()

  pos <- rdm.pos.vec[i]
  X <- rbind(train.X, S[-pos, ])
  alphas <- BayesianNaiveBayes(X, Y, prior.alpha.1, prior.alpha.0,
                               prior.prob)
  length.left <- ceiling(runif(1, min = minL - 1, max = maxL))
	length.right <- ceiling(runif(1, min = minR - 1, max = maxR))
  best.peptide <- GenOnePeptideMAPOld(length.left, length.right,
                                      alphas$post.alpha.1,
                                      alphas$post.alpha.0, NB.ITER)
  
  heldout.x <- S[pos, ]
  S[pos, ] <- best.peptide

  ##########################################
  # test uniqueness of each row of S
  # comment out if test is unnecessary
  #while(nrow(unique(S)) < NUM.RECOM) {
  #  print("Found a duplicate peptide!")
  #  length.left <- ceiling(runif(1, min = minL - 1, max = maxL))
	#  length.right <- ceiling(runif(1, min = minR - 1, max = maxR))
  #  best.peptide <- GenOnePeptideMAPOld(length.left, length.right,
  #                                      alphas$post.alpha.1,
  #                                      alphas$post.alpha.0, NB.ITER)
  #  S[pos, ] <- best.peptide
  #}
  ##########################################

  ptm.1 <- proc.time()
  print(sprintf("Until computing PI(S) costs %1.2f", (ptm.1 - ptm.0)[1]))

  # prob.improv.S[i] <- ComputeProbImprovOfSet(S, X_type1, Y_type1, AAclass,
  #                                            S.Pos, maxL, maxR, 
  #                                            gamma_0_type1, gamma_1_type1,
  #                                            prior_type1, NB.iter)
  prob.improv.S[i] <- ComputeProbImprovOfSet(S, train.X, train.Y,
                                             prior.alpha.1,
                                             prior.alpha.0, 
                                             prior.prob, NB.ITER)

  if (i > 1 && prob.improv.S[i] < prob.improv.S[i - 1]) {
    prob.improv.S[i] <- prob.improv.S[i - 1]
    S[pos, ] <- heldout.x
  }

  print(sprintf("Computing PI(S) costs %1.2f", (proc.time() - ptm.1)[1]))
  print(sprintf("PI(S) = %.3f", prob.improv.S[i]))
  print("==========")
}

